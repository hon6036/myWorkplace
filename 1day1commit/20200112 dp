백준 1932

정수 삼각형

        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
위 그림은 크기가 5인 정수 삼각형의 한 모습이다.

맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 

아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.

삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.

5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5

예제 입력을 분석해
리스트 형태로 저장한다
s
[[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]]

삼각형의 자리는
                   s[0][0]
             s[1][0]    s[1][1]
       s[2][0]   s[2][1]    s[2][2]
   s[3][0]  s[3][1]    s[3][2]    s[3][3]
s[4][0]  s[4][1]   s[4][2]    s[4][3]    s[4][4]

이런식으로 되며 위에서 부터 내려오면서 맨 왼쪽과 맨 오른쪽은 바로 위에 있는 수를 더하고 그 외의 것은 위의 두개 더한것중 최대값을 더하면 된다
따라서 하나씩 줄여보면
          s[1][0]+s[0][0]    s[1][1] + s[0][0]

이고

        s[2][0]+s[1][0]+s[0][0]   max(s[2][1] + s[1][0]+s[0][0], s[2][1] + s[1][1] + s[0][0])    s[2][2] + s[1][1] + s[0][0]
이런식 이므로 코드를 짜면 아래와 같이 된다

a = int(input())
s = []
for i in range(a):
    s.append(list(map(int,input().split())))

k = 2
for i in range(1,a):
    for j in range(k):
        if j == 0:
            s[i][j] = s[i][j] + s[i-1][j]
        elif i == j:
            s[i][j] = s[i][j] + s[i-1][j-1]
        else:
            s[i][j] = max(s[i-1][j-1], s[i-1][j]) + s[i][j]
    k += 1
print(max(s[a-1]))


백준 2579

계단 오르는 데는 다음과 같은 규칙이 있다.

1. 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
2. 연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
3. 마지막 도착 계단은 반드시 밟아야 한다.
따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.

각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.

마지막 계단을 꼭 밟아야 되므로
마지막 계단을 밟을 경우는 전 계단을 밟았을 때와 전 계단을 밟지 않았을 때가 있다.
dp는 계단 누적 합을 나타내는데
dp[0]에는 처음 계단
dp[1]에는 처음 계단과 그 다음 계단의 합
dp[2]에는 처음 계단과 세번째 계단의 합과 두번째 계단과 세번째 계단의 합


a = int(input(0))
s = []
dp = [0 for i in range(a)]
for _ in range(a):
    s.append(int(input()))

dp[0] = s[0]
dp[1] = s[0] + s[1]
dp[2] = max(s[0] + s[2], s[1] + s[2])
for i in range(3,a):
    dp[i] = max(dp[i-2] + s[i], dp[i-3] + s[i] + s[i-1])
print(dp[a-1])

백준 1463

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 
연산을 사용하는 횟수의 최솟값을 출력하시오.

규칙을 찾아야 한다
X가 0과 1이면 0개가 되고
X가 2면 2로 나눌 경우와 1을 뺄경우로 1개가 되고
X가 3이면 3으로 나눌 경우로 1개가 되고
X가 4면 2로 나누고 1를 뺄 경우와 1를 뺴고 3으로 나눌경우 2개가 된다

이렇게 하면 2와 3에서 시작한다는것을 알고
dp라는 리스트를 만들어 차례로 채워 넣되 최소값을 찾아서 넣어야 한다
우선 dp 리스트에 1을 뺀 경우 부터 채워 넣고
2로 나눠지면 dp[i] = min(dp[i], dp[i//2] + 1)
3으로 나눠지면 dp[i] = min(dp[i], dp[i//3] + 1) 이런식으로 구한다.


n = int(input())
dp = [0, 0, 1, 1]
for i in range(4,n+1):
    dp.append(dp[i-1] + 1)
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i//2] + 1)
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i//3] + 1)
print(dp[n])

        

